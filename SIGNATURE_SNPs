My Drive
DETAILS
ACTIVITY
Select a file or folder to view its details.
Get notifications on your computer for shared files and important events.
TURN ON


library(adegenet)
library(caret)
library(pforeach)
library(kknn)

source("C:/Rlib/WC84.R")

setwd("C:/Users/mortenma/Google Drive/post doc/essential files/paper 1/test")

data=read.PLINK("SNP.QC.population.raw",parallel=FALSE)

# scandinavia only only
data2=data[-8:-15,]
pop=c(rep("south",7),rep("south",8),rep("south",10),rep("west",24),rep("south",8))
corkwing=cbind(as.data.frame(pop),as.data.frame(data2))
# keep pop info
pop=corkwing$pop
# create folds
folds <- cut(seq(1,nrow(corkwing)),breaks=5,labels=FALSE)
# create snp interval
interval=seq(0,100,1)[-1:-2]

result2=matrix(ncol=5,nrow=length(interval))

for (a in 1:10) {
	#Randomly shuffle  data
	corkwing<-corkwing[sample(nrow(corkwing)),]

	# create empty results object
	result.kknn=matrix(ncol=5,nrow=length(interval))

	result.fst=pforeach(i = 1:5,.export=ls(envir=globalenv()),.combine=cbind)({
			index <- which(folds==i,arr.ind=TRUE)
			test <- corkwing[index,]
		        train <- corkwing[-index,]
			# get SNP wise Fst for each fold	
			WC84(train[,-1],train$pop)$theta})
			
			# loop through fst matrix
			for (i in 1:5) {
			index <- which(folds==i,arr.ind=TRUE)
			test <- corkwing[index,]
		        train <- corkwing[-index,]
		        FST=sort(result.fst[,i],decreasing=T)
	
	    				## loop through the best snps for each fold
					for (j in 1:length(interval)){
				
					test.corkwing.fst=cbind(test[,1],test[,colnames(test)%in%names(FST[1:interval[j]])])
					colnames(test.corkwing.fst)[1]="pop"
		
					train.corkwing.fst=cbind(train[,1],train[,colnames(train)%in%names(FST[1:interval[j]])])
					colnames(train.corkwing.fst)[1]="pop"
					
		        		res.fst = kknn(pop~., train.corkwing.fst, test.corkwing.fst, distance = 1,kernel = "rectangular")
		        		fit.fst <- fitted(res.fst)   
		        		confusion.fst=table(test.corkwing.fst$pop, fit.fst)
		        		# calculate accuracy pr fold pr snps
		        		result.kknn[j,i]=sum(diag(confusion.fst))/length(index)
		        		} 
		        }
		        
	# paste results from  10 repetitions	        
	result2=cbind(result2,result.kknn)
}
# clean up 
final=result2[,-1:-5]

x=1:99
sds=apply(final,1,sd)
lower=rowMeans(final)-sds
upper=rowMeans(final)+sds
upper[upper>1]=1
plot.ts(rowMeans(final),ylim=c(0.8,1),ylab="Accuracy",xlab="# SNPs")
lines(x,lower,col="gray")
lines(x,upper,col="gray")
polygon(c(x,rev(x)),c(upper,rev(lower)),col="gray")
lines(rowMeans(final))

arrows(x, 2*lower, x,upper, length=0.05, angle=90, code=0)






### Evaluate Pritchard Tono salmon vs escapees using the same method as above, Fst and KNN classification with repeated cross validation
### data was downloaded from data dryad and plink files recoded to raw format (--recodeA)
## http://datadryad.org/bitstream/handle/10255/dryad.120385/Genotyping_allelotyping.tar.gz?sequence=1

library(adegenet)
library(caret)
library(pforeach)
library(kknn)

source("C:/Rlib/WC84.R")

setwd("E:/data/salmon")
data=read.PLINK("Pritchardetal_genotypes.raw.raw",parallel=FALSE)
info=read.table("Individuals_and_pooling.csv",sep=",",header=T)

pop(data)=c(rep("Esc",192),rep("Teno",619),rep("Tornio",114))

# remove Tornio data
data2=as.data.frame(data)
data3=data2[1:811,]
data3=as.data.frame(data3)
rm(data)
rm(data2)

# replace missing values with column mean
index <- which(is.na(data3), arr.ind=TRUE)
data3[index] <- round(colMeans(data3,  na.rm = TRUE)[index[,1]],0)
# save imputed data to R object
# save(data3,file="imputed_salmon.Rda")
load("imputed_salmon.Rda")
memory.limit(size=6000)

### now we have summed up loadings for the most important compnenets from each of the PCA's
### now run through the top SNPs and test if classification methods can pretict status


pop=c(rep("esc",192),rep("wt",619))

data4=cbind(as.data.frame(pop),as.data.frame(data3))
data5=data4[1:384,]
data6<-data5[sample(nrow(data5)),]
salmon=data6[1:100,] # use random 100 salmon
rm(data3,data4,data5,data6)

folds <- cut(seq(1,nrow(salmon)),breaks=5,labels=FALSE)
# create snp interval
interval=seq(0,100,1)[-1:-2]

result2=matrix(ncol=5,nrow=length(interval))

for (a in 1:10) {
	#Randomly shuffle  data
	salmon<-salmon[sample(nrow(salmon)),]

	# create empty results object
	result.kknn=matrix(ncol=5,nrow=length(interval))

	result.fst=pforeach(i = 1:5,.export=ls(envir=globalenv()),.combine=cbind)({
			index <- which(folds==i,arr.ind=TRUE)
			test <- salmon[index,]
		        train <- salmon[-index,]
			# get SNP wise Fst for each fold	
			WC84(train[,-1],train$pop)$theta})
			
			# loop through fst matrix
			for (i in 1:5) {
			index <- which(folds==i,arr.ind=TRUE)
			test <- salmon[index,]
		        train <- salmon[-index,]
		        FST=sort(result.fst[,i],decreasing=T)
	
	    				## loop through the best snps for each fold
					for (j in 1:length(interval)){
				
					test.salmon.fst=cbind(test[,1],test[,colnames(test)%in%names(FST[1:interval[j]])])
					colnames(test.salmon.fst)[1]="pop"
		
					train.salmon.fst=cbind(train[,1],train[,colnames(train)%in%names(FST[1:interval[j]])])
					colnames(train.salmon.fst)[1]="pop"
					
		        		res.fst = kknn(pop~., train.salmon.fst, test.salmon.fst, distance = 1,kernel = "rectangular")
		        		fit.fst <- fitted(res.fst)   
		        		confusion.fst=table(test.salmon.fst$pop, fit.fst)
		        		# calculate accuracy pr fold pr snps
		        		result.kknn[j,i]=sum(diag(confusion.fst))/length(index)
		        		} 
		        }
		        
	# paste results from  10 repetitions	        
	result2=cbind(result2,result.kknn)
}
# clean up 
final_salmon=result2[,-1:-5]



x=1:100

plot(result.salmon.knn[,4],ylim=c(0,1),type="b",pch=15,cex=1,xlab="# SNPs",ylab="Accuracy with SD",main="KNN")
arrows(x, as.numeric(result.salmon.knn[,4])-as.numeric(result.salmon.knn[,6]), x, as.numeric(result.salmon.knn[,4])+as.numeric(result.salmon.knn[,6]), length=0.05, angle=90, code=0)



#### evaluate anchovy from medeterranian vs antlantic

library(adegenet)
library(caret)
library(pforeach)
library(kknn)

source("C:/Rlib/WC84.R")

setwd("E:/data/salmon")

med=read.PLINK("MED_mac_1.raw",parallel=FALSE)
atl=read.PLINK("ATL_mac_1.raw",parallel=FALSE)

med1=as.data.frame(med)
atl1=as.data.frame(atl)

# replace missing values with column mean
index <- which(is.na(med1), arr.ind=TRUE)
med1[index] <- round(colMeans(med1,  na.rm = TRUE)[index[,1]],0)

# replace missing values with column mean
index <- which(is.na(atl1), arr.ind=TRUE)
atl1[index] <- round(colMeans(atl1,  na.rm = TRUE)[index[,1]],0)


MED=med1[colnames(med1)%in%colnames(atl1)]
ATL=atl1[colnames(atl1)%in%colnames(med1)]

ANT=rbind(ATL,MED)

pop=c(rep("atl",41),rep("med",48))

ant=cbind(as.data.frame(pop),as.data.frame(ANT))

folds <- cut(seq(1,nrow(ant)),breaks=5,labels=FALSE)
# create snp interval
interval=seq(0,100,1)[-1:-2]


result2=matrix(ncol=5,nrow=length(interval))

for (a in 1:10) {
	#Randomly shuffle  data
	ant<-ant[sample(nrow(ant)),]

	# create empty results object
	result.kknn=matrix(ncol=5,nrow=length(interval))

	result.fst=pforeach(i = 1:5,.export=ls(envir=globalenv()),.combine=cbind)({
			index <- which(folds==i,arr.ind=TRUE)
			test <- ant[index,]
		        train <- ant[-index,]
			# get SNP wise Fst for each fold	
			WC84(train[,-1],train$pop)$theta})
			
			# loop through fst matrix
			for (i in 1:5) {
			index <- which(folds==i,arr.ind=TRUE)
			test <- ant[index,]
		        train <- ant[-index,]
		        FST=sort(result.fst[,i],decreasing=T)
	
	    				## loop through the best snps for each fold
					for (j in 1:length(interval)){
				
					test.ant.fst=cbind(test[,1],test[,colnames(test)%in%names(FST[1:interval[j]])])
					colnames(test.ant.fst)[1]="pop"
		
					train.ant.fst=cbind(train[,1],train[,colnames(train)%in%names(FST[1:interval[j]])])
					colnames(train.ant.fst)[1]="pop"
					
		        		res.fst = kknn(pop~., train.ant.fst, test.ant.fst, distance = 1,kernel = "rectangular")
		        		fit.fst <- fitted(res.fst)   
		        		confusion.fst=table(test.ant.fst$pop, fit.fst)
		        		# calculate accuracy pr fold pr snps
		        		result.kknn[j,i]=sum(diag(confusion.fst))/length(index)
		        		} 
		        }
		        
	# paste results from  10 repetitions	        
	result2=cbind(result2,result.kknn)
}
# clean up 
final_ant=result2[,-1:-5]

x=1:99
sds=apply(final_ant,1,sd)
lower=rowMeans(final_ant)-sds
upper=rowMeans(final_ant)+sds
upper[upper>1]=1
plot.ts(rowMeans(final_ant),ylim=c(0.8,1),ylab="Accuracy",xlab="# SNPs")
lines(x,lower,col="red")
lines(x,upper,col="red")
polygon(c(x,rev(x)),c(upper,rev(lower)),col="pink")
lines(rowMeans(final_ant),col="red")



salmon=read.table("CV_KNN_salmon.txt")
ant=read.table("CV_KNN_anchovy.txt")
corkwing=read.table("CV_KNN_corkwing.txt")

x=2:100

Cairo(file="CV.pdf",type="pdf",width=160,height=80,units="mm")
par(mar = c(4,4,1,1))
plot.ts(rowMeans(corkwing),ylim=c(0.7,1),ylab="Accuracy",xlab="# SNPs",type="b",pch=19,col="white",cex.axis=0.1,cex.lab=0.1)

corkwing.sds=apply(corkwing,1,sd)
salmon.sds=apply(salmon,1,sd)
ant.sds=apply(ant,1,sd)

lines(x,rowMeans(corkwing),col="black",pch=19,lwd=2)
lines(x,rowMeans(ant),col="blue",pch=19,lwd=2)
lines(x,rowMeans(salmon),col="red",pch=19,lwd=2)

## lower
lines(rowMeans(corkwing)-corkwing.sds,col=alpha("black",0.5),lty=3,lwd=2)
lines(rowMeans(salmon)-salmon.sds,col=alpha("red",0.5),lty=3,lwd=2)
lines(rowMeans(ant)-ant.sds,col=alpha("blue",0.5),lty=3,lwd=2)

abline(h=1)
grid()
dev.off()









